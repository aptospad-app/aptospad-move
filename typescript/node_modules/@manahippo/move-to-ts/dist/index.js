'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var aptos = require('aptos');
var stringify = require('json-stable-stringify');
var bigInt = require('big-integer');
var sha = require('sha.js');
var sha3 = require('sha3');
var elliptic = require('elliptic');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var stringify__default = /*#__PURE__*/_interopDefaultLegacy(stringify);
var bigInt__default = /*#__PURE__*/_interopDefaultLegacy(bigInt);
var sha__namespace = /*#__PURE__*/_interopNamespace(sha);
var elliptic__namespace = /*#__PURE__*/_interopNamespace(elliptic);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function assert$1(cond, msg = "") {
    if (!cond) {
        throw new Error(msg);
    }
}

exports.AtomicTypeTag = void 0;
(function (AtomicTypeTag) {
    AtomicTypeTag["Bool"] = "bool";
    AtomicTypeTag["U8"] = "u8";
    AtomicTypeTag["U64"] = "u64";
    AtomicTypeTag["U128"] = "u128";
    AtomicTypeTag["Address"] = "address";
    AtomicTypeTag["Signer"] = "signer";
})(exports.AtomicTypeTag || (exports.AtomicTypeTag = {}));
function isAtomicTypeTag(val) {
    return (typeof val === 'string' && Object.values(exports.AtomicTypeTag).includes(val));
}
class StructTag$1 {
    constructor(address, module, name, typeParams) {
        this.address = address;
        this.module = module;
        this.name = name;
        this.typeParams = typeParams;
        this.kind = 'StructTag';
    }
    static isInstance(val) {
        return val.kind && val.kind === 'StructTag';
    }
    getFullname() {
        const typeParamString = getTypeParamsString(this.typeParams);
        return `${this.address.hex()}::${this.module}::${this.name}${typeParamString}`;
    }
    getShortAddressFullName() {
        const typeParamString = getTypeParamsString(this.typeParams);
        return `${this.address.toShortString()}::${this.module}::${this.name}${typeParamString}`;
    }
    getParamlessName() {
        return `${this.address.hex()}::${this.module}::${this.name}`;
    }
    getShortAddressParamlessName() {
        return `${this.address.toShortString()}::${this.module}::${this.name}`;
    }
    getAptosMoveTypeTag() {
        return this.getFullname();
        /*
        return {
          address: this.address.toShortString(),
          module: this.module,
          name: this.name,
          generic_type_params: this.typeParams.map(getTypeTagFullname,)
        };
        */
    }
}
class SimpleStructTag extends StructTag$1 {
    constructor(structInfo, typeParams = []) {
        super(structInfo.moduleAddress, structInfo.moduleName, structInfo.structName, typeParams);
        this.structInfo = structInfo;
    }
}
class VectorTag {
    constructor(elementType) {
        this.elementType = elementType;
        this.kind = 'VectorTag';
    }
    static isInstance(val) {
        return val.kind && val.kind === 'VectorTag';
    }
}
class TypeParamIdx {
    constructor(index) {
        this.index = index;
        this.kind = "TypeParamIdx";
    }
    static isInstance(val) {
        return val.kind && val.kind === 'TypeParamIdx';
    }
}
function getTypeTagFullnameInner(typeTag, shortAddress) {
    if (VectorTag.isInstance(typeTag)) {
        const vecTag = typeTag;
        return `vector<${getTypeTagFullname(vecTag.elementType)}>`;
    }
    else if (StructTag$1.isInstance(typeTag)) {
        const structTag = typeTag;
        return shortAddress ?
            structTag.getShortAddressFullName() : structTag.getFullname();
    }
    else if (TypeParamIdx.isInstance(typeTag)) {
        return `$tv${typeTag.index}`;
    }
    else if (isAtomicTypeTag(typeTag)) {
        return typeTag;
    }
    else {
        throw new Error(`Unrecognized type: ${typeTag}`);
    }
}
function getTypeTagFullname(typeTag) {
    return getTypeTagFullnameInner(typeTag, false);
}
function getShortAddressTypeTagFullname(typeTag) {
    return getTypeTagFullnameInner(typeTag, true);
}
function getTypeTagParamlessNameInner(typeTag, shortAddress = false) {
    if (VectorTag.isInstance(typeTag)) {
        return `vector`;
    }
    else if (StructTag$1.isInstance(typeTag)) {
        const structTag = typeTag;
        return shortAddress ?
            structTag.getShortAddressParamlessName() : structTag.getParamlessName();
    }
    else if (TypeParamIdx.isInstance(typeTag)) {
        return `$tv${typeTag.index}`;
    }
    else if (isAtomicTypeTag(typeTag)) {
        return typeTag;
    }
    else {
        throw new Error(`Unrecognized type: ${typeTag}`);
    }
}
function getTypeTagParamlessName(typeTag) {
    return getTypeTagParamlessNameInner(typeTag, false);
}
function getShortAddressTypeTagParamlessName(typeTag) {
    return getTypeTagParamlessNameInner(typeTag, true);
}
function getTypeParamsString(typeParams) {
    if (typeParams.length === 0) {
        return "";
    }
    return `<${typeParams.map(getTypeTagFullname).join(", ")}>`;
}
function splitByDoubleColon(name) {
    const endIdx = name.indexOf("::");
    assert$1(endIdx >= 0);
    assert$1(name.length > endIdx + 2);
    return [name.substr(0, endIdx), name.substr(endIdx + 2)];
}
function parseQualifiedStructTag(name) {
    const isQualifiedStruct = name.includes("::");
    if (!isQualifiedStruct) {
        return [null, name];
    }
    const [address, withoutAddress] = splitByDoubleColon(name);
    const hexAddress = new aptos.HexString(address);
    const [module, withoutModule] = splitByDoubleColon(withoutAddress);
    // structName<...>
    if (withoutModule.match(/^[a-zA-Z_][a-zA-Z_0-9]*</)) {
        const leftBracketIdx = withoutModule.indexOf("<");
        const structName = withoutModule.substr(0, leftBracketIdx);
        const afterLeftBracket = withoutModule.substr(leftBracketIdx + 1);
        const typeParams = [];
        let [result, remaining] = parseTypeTag(afterLeftBracket);
        while (true) {
            if (result === null) {
                throw new Error(`Badly formatted struct name: ${name}`);
            }
            typeParams.push(result);
            // consume the closing bracket
            if (remaining.startsWith(">")) {
                return [
                    new StructTag$1(hexAddress, module, structName, typeParams),
                    remaining.substr(1),
                ];
            }
            // more params to parse
            else if (remaining.startsWith(", ")) {
                [result, remaining] = parseTypeTag(remaining.substr(2));
            }
            else if (remaining.startsWith(",")) {
                [result, remaining] = parseTypeTag(remaining.substr(1));
            }
            else {
                throw new Error(`Badly formatted struct name: ${name}`);
            }
        }
    }
    // just structName
    else {
        // structName could be followed by ',' or '>'
        const commaIdx = withoutModule.indexOf(",");
        const brackIdx = withoutModule.indexOf(">");
        if (commaIdx === -1 && brackIdx === -1) {
            // fully consumed
            return [new StructTag$1(hexAddress, module, withoutModule, []), ""];
        }
        const separatorIdx = commaIdx === -1 ? brackIdx : Math.min(commaIdx, brackIdx);
        return [
            new StructTag$1(hexAddress, module, withoutModule.substr(0, separatorIdx), []),
            withoutModule.substr(separatorIdx),
        ];
    }
}
function parseVectorTag(name) {
    if (!name.startsWith("vector<")) {
        return [null, name];
    }
    let [elementType, remaining] = parseTypeTag(name.substr(7));
    if (elementType === null || !remaining.startsWith(">")) {
        throw new Error(`Badly formatted vector type name: ${name}`);
    }
    // consume the remaining '>'
    return [new VectorTag(elementType), remaining.substr(1)];
}
function parseAtomicTag(name) {
    const atomicTags = Object.values(exports.AtomicTypeTag);
    for (const tag of atomicTags) {
        const value = tag;
        if (name.startsWith(value)) {
            // fully consumed the name
            if (name.length === value.length) {
                return [value, ""];
            }
            // the name is an AtomicTypeTag followed by other template elements
            else if ([",", ">"].includes(name[value.length])) {
                return [value, name.substr(value.length)];
            }
            // miss
        }
    }
    return [null, name];
}
const CHAR_CODE_0 = "0".charCodeAt(0);
const CHAR_CODE_9 = "9".charCodeAt(0);
function parseTypeParameter(name) {
    if (!name.startsWith("$tv")) {
        return [null, name];
    }
    let idx = 3;
    for (; idx < name.length; idx++) {
        const charCode = name.charCodeAt(idx);
        if (charCode >= CHAR_CODE_0 && charCode <= CHAR_CODE_9) {
            continue;
        }
        break;
    }
    if (idx === 3) {
        throw new Error(`Failed to find number after $tv in :${name}`);
    }
    const paramIdx = parseInt(name.substr(3, idx - 3));
    return [new TypeParamIdx(paramIdx), name.substr(idx)];
}
function parseTypeTag(name) {
    const [atomicResult, remaining1] = parseAtomicTag(name);
    if (atomicResult !== null) {
        return [atomicResult, remaining1];
    }
    const [vectorResult, remaining2] = parseVectorTag(name);
    if (vectorResult !== null) {
        return [vectorResult, remaining2];
    }
    const [structResult, remaining3] = parseQualifiedStructTag(name);
    if (structResult !== null) {
        return [structResult, remaining3];
    }
    const [tvResult, remaining4] = parseTypeParameter(name);
    if (tvResult !== null) {
        return [tvResult, remaining4];
    }
    throw new Error(`Bad typetag: ${name}`);
}
function parseTypeTagOrThrow(name) {
    const [tag, remaining] = parseTypeTag(name);
    if (!tag || remaining.length > 0) {
        throw new Error(`Invalid type tag: ${name}`);
    }
    return tag;
}
function parseMoveStructTag(moveTag) {
    const result = parseTypeTagOrThrow(moveTag);
    if (!(StructTag$1.isInstance(result))) {
        throw new Error(`Expected a StructTag but instead received: ${moveTag}`);
    }
    return result;
    // MoveStructTag was for a while a struct
    // const params = moveTag.generic_type_params.map(parseTypeTagOrThrow);
    // return new StructTag(new HexString(moveTag.address), moveTag.module, moveTag.name, params);
}
function parseResourceType(fullname) {
    const [result, remaining] = parseQualifiedStructTag(fullname);
    if (result === null || remaining.length !== 0) {
        throw new Error(`Badly formatted resource type: ${fullname}`);
    }
    return result;
}
function substituteTypeParams(toSubstitute, typeParams) {
    if (StructTag$1.isInstance(toSubstitute)) {
        let params = toSubstitute.typeParams.map((p) => substituteTypeParams(p, typeParams));
        return new StructTag$1(toSubstitute.address, toSubstitute.module, toSubstitute.name, params);
    }
    else if (VectorTag.isInstance(toSubstitute)) {
        const innerSubbed = substituteTypeParams(toSubstitute.elementType, typeParams);
        return new VectorTag(innerSubbed);
    }
    else if (TypeParamIdx.isInstance(toSubstitute)) {
        let subbed = typeParams[toSubstitute.index];
        if (!subbed) {
            throw new Error(`Did not find param ${toSubstitute.index} in ${JSON.stringify(typeParams)}`);
        }
        return subbed;
    }
    else {
        // AtomicTypeTag
        return toSubstitute;
    }
}
function isTypeTagConcrete(tag) {
    if (TypeParamIdx.isInstance(tag)) {
        return false;
    }
    else if (StructTag$1.isInstance(tag)) {
        // if all the parameters are filled with concret types instead of TypeParamIdx
        for (const tv of tag.typeParams) {
            if (!isTypeTagConcrete(tv)) {
                return false;
            }
        }
        return true;
    }
    else if (VectorTag.isInstance(tag)) {
        return isTypeTagConcrete(tag.elementType);
    }
    else {
        // AtomicTypeTag
        return true;
    }
}

class DummyCache {
    // synchronous builtins
    exists(_tag, _address) {
        throw new Error("DummyCache does not support 'exists'");
    }
    move_to(_tag, _address, _resource) {
        throw new Error("DummyCache does not support 'move_to'");
    }
    set(_tag, _address, _resource) {
        throw new Error("DummyCache does not support 'set'");
    }
    move_from(_tag, _address) {
        throw new Error("DummyCache does not support 'move_from'");
    }
    borrow_global(_tag, _address) {
        throw new Error("DummyCache does not support 'borrow_global'");
    }
    borrow_global_mut(_tag, _address) {
        throw new Error("DummyCache does not support 'borrow_global_mut'");
    }
    // async builtins
    exists_async(_tag, _address) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.exists(_tag, _address);
        });
    }
    move_to_async(_tag, _address, _resource) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.move_to(_tag, _address, _resource);
        });
    }
    move_from_async(_tag, _address) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.move_from(_tag, _address);
        });
    }
    borrow_global_async(_tag, _address) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.borrow_global(_tag, _address);
        });
    }
    borrow_global_mut_async(_tag, _address) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.borrow_global_mut(_tag, _address);
        });
    }
    // table
    table_new_handle() {
        throw new Error("DummyCache does not support table_new_handle");
    }
    table_add_box(table, key, value) {
        throw new Error("DummyCache does not support table_add_box");
    }
    table_borrow_box(table, key) {
        throw new Error("Not implemented");
    }
    table_borrow_box_mut(table, key) {
        throw new Error("Not implemented");
    }
    table_contains_box(table, key) {
        throw new Error("Not implemented");
    }
    table_remove_box(table, key) {
        throw new Error("Not implemented");
    }
    table_destroy_empty_box(table) {
        throw new Error("Not implemented");
    }
    table_drop_unchecked_box(table) {
        throw new Error("Not implemented");
    }
}
class AccountCache {
    constructor(address) {
        this.address = address;
        this.resources = new Map();
    }
    has(tag) {
        return this.resources.has(getShortAddressTypeTagFullname(tag));
    }
    has_async(tag, repo, client) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.get_async(tag, repo, client);
                return true;
            }
            catch (e) {
                return false;
            }
        });
    }
    get(tag) {
        const fullname = getShortAddressTypeTagFullname(tag);
        const resource = this.resources.get(fullname);
        if (!resource) {
            throw new Error(`Account ${this.address.toShortString()} does not have resource: ${fullname}`);
        }
        return resource;
    }
    get_async(tag, repo, client) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(tag instanceof StructTag$1)) {
                throw new Error(`Expected StructTag`);
            }
            try {
                const resource = yield client.getAccountResource(this.address, tag.getAptosMoveTypeTag());
                return repo.parse(resource.data, tag);
            }
            catch (e) {
                throw new Error(`Account ${this.address.toShortString()} does not have resource ${getShortAddressTypeTagFullname(tag)}`);
            }
        });
    }
    set(tag, resource, overwrite = false) {
        const fullname = getShortAddressTypeTagFullname(tag);
        if (this.has(tag) && !overwrite) {
            throw new Error(`Account ${this.address.toShortString()} already has resource: ${fullname}`);
        }
        this.resources.set(fullname, resource);
    }
    move_from(tag) {
        const fullname = getShortAddressTypeTagFullname(tag);
        const resource = this.resources.get(fullname);
        if (!resource) {
            throw new Error(`Account ${this.address.toShortString()} does not have resource: ${fullname}`);
        }
        this.resources.delete(fullname);
        return resource;
    }
}
// caches all data locally and never attempts to retrieve anything from chain
// only suited for running tests
class AptosLocalCache {
    constructor() {
        this.accounts = new Map();
        this.tables = new Map();
        this.nextTableHandle = 1;
    }
    // synchronous builtins
    exists(tag, address) {
        const account = this.accounts.get(address.toShortString());
        if (!account) {
            return false;
        }
        return account.has(tag);
    }
    move_to(tag, address, resource, overwrite = false) {
        let account = this.accounts.get(address.toShortString());
        if (!account) {
            account = new AccountCache(address);
            this.accounts.set(address.toShortString(), account);
        }
        account.set(tag, resource, overwrite);
    }
    set(tag, address, resource) {
        this.move_to(tag, address, resource, true);
    }
    move_from(tag, address) {
        let account = this.accounts.get(address.toShortString());
        if (!account) {
            throw new Error(`Resource ${getShortAddressTypeTagFullname(tag)} does not exist for ${address.toShortString()}`);
        }
        return account.move_from(tag);
    }
    borrow_global(tag, address) {
        let account = this.accounts.get(address.toShortString());
        if (!account) {
            throw new Error(`Resource ${getShortAddressTypeTagFullname(tag)} does not exist for ${address.toShortString()}`);
        }
        return account.get(tag);
    }
    borrow_global_mut(tag, address) {
        return this.borrow_global(tag, address);
    }
    // async builtins
    exists_async(_tag, _address) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.exists(_tag, _address);
        });
    }
    move_to_async(_tag, _address, _resource) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.move_to(_tag, _address, _resource, true);
        });
    }
    move_from_async(_tag, _address) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.move_from(_tag, _address);
        });
    }
    borrow_global_async(_tag, _address) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.borrow_global(_tag, _address);
        });
    }
    borrow_global_mut_async(_tag, _address) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.borrow_global_mut(_tag, _address);
        });
    }
    // table
    table_get_or_create(handle) {
        const table = this.tables.get(handle.toString());
        if (table) {
            return table;
        }
        else {
            const newTable = new Map();
            this.tables.set(handle.toShortString(), newTable);
            return newTable;
        }
    }
    table_new_handle() {
        const handleIdx = this.nextTableHandle++ + 0x10000000;
        const handleStr = `${handleIdx.toString(16)}`;
        const handle = new aptos.HexString(handleStr);
        const table = new Map();
        this.tables.set(handle.toShortString(), table);
        return handle;
    }
    table_add_box(table, key, value) {
        const tableMap = this.table_get_or_create(table.handle);
        const stringKey = stringify__default["default"](key);
        if (tableMap.has(stringKey)) {
            throw new Error("key already exists");
        }
        tableMap.set(stringKey, value);
    }
    table_borrow_box(table, key) {
        const tableMap = this.table_get_or_create(table.handle);
        const stringKey = stringify__default["default"](key);
        const value = tableMap.get(stringKey);
        if (!value) {
            throw new Error("key does not exist");
        }
        return value;
    }
    table_borrow_box_mut(table, key) {
        return this.table_borrow_box(table, key);
    }
    table_contains_box(table, key) {
        const tableMap = this.table_get_or_create(table.handle);
        const stringKey = stringify__default["default"](key);
        return tableMap.has(stringKey);
    }
    table_remove_box(table, key) {
        const tableMap = this.table_get_or_create(table.handle);
        const stringKey = stringify__default["default"](key);
        const entry = tableMap.get(stringKey);
        if (!entry) {
            throw new Error("Key does not exist");
        }
        tableMap.delete(stringKey);
        return entry;
    }
    table_destroy_empty_box(table) {
        // NOP
    }
    table_drop_unchecked_box(table) {
        // NOP
    }
}
// caches data locally, and attempts to fetch from chain when needed
class AptosSyncedCache extends AptosLocalCache {
    constructor(repo, client) {
        super();
        this.repo = repo;
        this.client = client;
    }
    // asynchronous builtins
    exists_async(tag, address) {
        return __awaiter(this, void 0, void 0, function* () {
            let account = this.accounts.get(address.toShortString());
            if (!account) {
                account = new AccountCache(address);
                this.accounts.set(address.toShortString(), account);
            }
            return account.has_async(tag, this.repo, this.client);
        });
    }
    move_to_async(tag, address, resource) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("move_to not supported by AptosSyncedCache");
        });
    }
    move_from_async(tag, address) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("move_from not supported by AptosSyncedCache");
        });
    }
    borrow_global_async(tag, address) {
        return __awaiter(this, void 0, void 0, function* () {
            let account = this.accounts.get(address.toShortString());
            if (!account) {
                account = new AccountCache(address);
                this.accounts.set(address.toShortString(), account);
            }
            return (yield account.get_async(tag, this.repo, this.client));
        });
    }
    borrow_global_mut_async(tag, address) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.borrow_global_async(tag, address);
        });
    }
}
class AptosResourceCache {
    constructor(client, repo) {
        this.client = client;
        this.repo = repo;
        this.cachedResources = {};
        this.updateListener = {};
        this.watchedAddresses = new Set();
        this.resourceKeyToLoadParams = {};
    }
    /*
    Load a specific resource
    */
    load(struct, address, typeParams, listener) {
        return __awaiter(this, void 0, void 0, function* () {
            const loaded = yield this.repo.loadResource(this.client, address, struct, typeParams);
            const typeTag = new StructTag$1(struct.moduleAddress, struct.moduleName, struct.structName, typeParams);
            const resourceKey = this.getResourceKey(address, typeTag);
            if (resourceKey in this.cachedResources) {
                this.updateResource(resourceKey, loaded);
            }
            else {
                this.cachedResources[resourceKey] = loaded;
            }
            this.resourceKeyToLoadParams[resourceKey] = [struct, address, typeParams];
            if (listener) {
                this.addListenerForResource(resourceKey, listener);
            }
            return loaded;
        });
    }
    /*
    Load all resources owned by an account
    */
    loadAccount(address, listener) {
        return __awaiter(this, void 0, void 0, function* () {
            const resources = yield this.client.getAccountResources(address);
            const loadedResourceKeys = [];
            for (const resource of resources) {
                const typeTag = parseMoveStructTag(resource.type);
                try {
                    const value = this.repo.parse(resource.data, typeTag);
                    const resourceKey = this.getResourceKey(address, typeTag);
                    if (resourceKey in this.cachedResources) {
                        this.updateResource(resourceKey, value);
                    }
                    else {
                        this.cachedResources[resourceKey] = value;
                    }
                    loadedResourceKeys.push(resourceKey);
                    if (listener) {
                        this.addListenerForResource(resourceKey, listener);
                    }
                }
                catch (e) {
                    console.log(`Failed to parse resource of type: ${resource.type}`);
                }
            }
            this.watchedAddresses.add(address);
            return loadedResourceKeys;
        });
    }
    /*
    Reload all resources that have been previously loaded
    */
    globalRefresh() {
        return __awaiter(this, void 0, void 0, function* () {
            /*
            1. refresh addresses
            2. refresh the rest one-by-one
            */
            const loaded = new Set();
            for (const address of this.watchedAddresses) {
                for (const resourceKey of yield this.loadAccount(address, null)) {
                    loaded.add(resourceKey);
                }
            }
            for (const resourceKey in this.cachedResources) {
                if (!loaded.has(resourceKey)) {
                    const [struct, address, typeParams] = this.resourceKeyToLoadParams[resourceKey];
                    yield this.load(struct, address, typeParams, null);
                    loaded.add(resourceKey);
                }
            }
        });
    }
    /*
    Add listener for a particular ResourceKey
    */
    addListenerForResource(resourceKey, listener) {
        if (!(resourceKey in this.updateListener)) {
            this.updateListener[resourceKey] = [];
        }
        for (const registeredListener of this.updateListener[resourceKey]) {
            if (registeredListener.id === listener.id) {
                return;
            }
        }
        this.updateListener[resourceKey].push(listener);
    }
    /*
    Use the return value from AptosClient.getTransaction(hash) to update the data cache, and notify listeners
  
    After client waits for transaction confirmation, the confirmed transaction comes with a set of "changes" that have
    taken place as a result of this transaction. We can feed that information directly through this interface to avoid the
    need to refresh the cache.
    */
    updateFromTransactionResult(txn) {
        if (txn.success && txn.hash !== "0x0") {
            for (const change of txn.changes) {
                if (change.type === "write_resource") {
                    const write = change;
                    const typeTag = parseMoveStructTag(write.data.type);
                    const resourceKey = this.getResourceKey(new aptos.HexString(write.address), typeTag);
                    if (resourceKey in this.cachedResources) {
                        const newValue = this.repo.parse(write.data.data, typeTag);
                        this.updateResource(resourceKey, newValue);
                    }
                }
                else if (change.type === "delete_resource") {
                    const del = change;
                    const typeTag = parseMoveStructTag(del.resource);
                    const resourceKey = this.getResourceKey(new aptos.HexString(del.address), typeTag);
                    if (resourceKey in this.cachedResources) {
                        this.deleteResource(resourceKey);
                    }
                }
            }
        }
    }
    /*
    Updates the resource cache and notifies listeners (if any)
    */
    updateResource(resourceKey, value) {
        this.cachedResources[resourceKey] = value;
        const listeners = this.updateListener[resourceKey];
        if (listeners) {
            for (const listener of listeners) {
                listener.callback("update", value);
            }
        }
    }
    /*
    Delete the resource and notifies listeners (if any)
    */
    deleteResource(resourceKey) {
        delete this.cachedResources[resourceKey];
        const listeners = this.updateListener[resourceKey];
        if (listeners) {
            for (const listener of listeners) {
                listener.callback("delete", null);
            }
        }
    }
    /*
    Computes ResourceKey from owner address and resource TypeTag
    */
    getResourceKey(ownerAddress, typeTag) {
        return `${ownerAddress.toShortString()}/${getShortAddressTypeTagFullname(typeTag)}`;
    }
}

function takeBigInt(from) {
    if (typeof from === "string") {
        return bigInt__default["default"](from);
    }
    else if (typeof from === "number") {
        return bigInt__default["default"](from);
    }
    else if (from instanceof UnsignedInt) {
        return from.value;
    }
    else {
        return from;
    }
}
class UnsignedInt {
    constructor(value) {
        this.value = takeBigInt(value);
        this.checkBounds();
    }
    checkBounds() { }
    min() { return bigInt__default["default"](); }
    max() { return bigInt__default["default"](); }
    make(value) {
        return new UnsignedInt(value);
    }
    copy() {
        return this.make(this.value);
    }
    toPayloadArg() {
        return this.value.toString();
    }
    toJsNumber() {
        return this.value.toJSNumber();
    }
    toBigInt() {
        return BigInt(this.value.toString());
    }
    $set(val) {
        this.value = val.value;
        this.checkBounds();
    }
    or(other) {
        return other.make(this.value.or(other.value));
    }
    and(other) {
        return other.make(this.value.and(other.value));
    }
    xor(other) {
        return other.make(this.value.xor(other.value));
    }
    add(other) {
        return other.make(this.value.add(other.value));
    }
    sub(other) {
        return other.make(this.value.subtract(other.value));
    }
    mul(other) {
        return other.make(this.value.multiply(other.value));
    }
    div(other) {
        if (other.value.eq(bigInt__default["default"].zero)) {
            throw new Error("Division by 0");
        }
        return other.make(this.value.divide(other.value));
    }
    mod(other) {
        return other.make(this.value.mod(other.value));
    }
    shl(other) {
        return this.make(this.value.shiftLeft(other.value).and(this.max()));
    }
    shr(other) {
        // FIXME: need to match this with move's implementation
        return this.make(this.value.shiftRight(other.value));
    }
    lt(other) {
        return this.value.lt(other.value);
    }
    le(other) {
        return this.value.leq(other.value);
    }
    eq(other) {
        return this.value.eq(other.value);
    }
    neq(other) {
        return this.value.neq(other.value);
    }
    gt(other) {
        return this.value.gt(other.value);
    }
    ge(other) {
        return this.value.geq(other.value);
    }
}
class U8 extends UnsignedInt {
    make(value) {
        return new U8(value);
    }
    checkBounds() {
        if (this.value.lt(U8.MIN) || this.value.gt(U8.MAX)) {
            throw new Error(`Value out of bounds for U8: ${this.value}`);
        }
    }
    min() { return U8.MIN; }
    max() { return U8.MAX; }
}
U8.MIN = bigInt__default["default"](0);
U8.MAX = bigInt__default["default"](255);
class U64 extends UnsignedInt {
    make(value) {
        return new U64(value);
    }
    checkBounds() {
        if (this.value.lt(U64.MIN) || this.value.gt(U64.MAX)) {
            throw new Error(`Value out of bounds for U64: ${this.value}`);
        }
    }
    min() { return U64.MIN; }
    max() { return U64.MAX; }
}
U64.MIN = bigInt__default["default"](0);
U64.MAX = bigInt__default["default"]("18446744073709551615");
class U128 extends UnsignedInt {
    make(value) {
        return new U128(value);
    }
    checkBounds() {
        if (this.value.lt(U128.MIN) || this.value.gt(U128.MAX)) {
            throw new Error(`Value out of bounds for U128: ${this.value}`);
        }
    }
    min() { return U128.MIN; }
    max() { return U128.MAX; }
}
U128.MIN = bigInt__default["default"](0);
U128.MAX = bigInt__default["default"]("340282366920938463463374607431768211455");

function abortCode(code) {
    if (code instanceof U64) {
        // consier making it nicer by parsing the first and second byte??
        return new Error(`${code.value.toString()}`);
    }
    return code;
}
function assert(cond, error) {
    if (!cond) {
        throw error;
    }
}
function u8(from) {
    return new U8(takeBigInt(from));
}
function u64(from) {
    return new U64(takeBigInt(from));
}
function u128(from) {
    return new U128(takeBigInt(from));
}
function deep_eq(lhs, rhs) {
    return stringify__default["default"](lhs) === stringify__default["default"](rhs);
}
function dyn_add(_tag, lhs, _rhs) {
    throw new Error("Not implemented");
}
function dyn_sub(_tag, _lhs, _rhs) {
    throw new Error("Not implemented");
}
function dyn_mul(_tag, _lhs, _rhs) {
    throw new Error("Not implemented");
}
function dyn_mod(_tag, _lhs, _rhs) {
    throw new Error("Not implemented");
}
function dyn_div(_tag, _lhs, _rhs) {
    throw new Error("Not implemented");
}
function dyn_bitor(_tag, _lhs, _rhs) {
    throw new Error("Not implemented");
}
function dyn_bitand(_tag, _lhs, _rhs) {
    throw new Error("Not implemented");
}
function dyn_xor(_tag, _lhs, _rhs) {
    throw new Error("Not implemented");
}
function dyn_shl(_tag, _lhs, _rhs) {
    throw new Error("Not implemented");
}
function dyn_shr(_tag, _lhs, _rhs) {
    throw new Error("Not implemented");
}
function dyn_and(_tag, _lhs, _rhs) {
    throw new Error("Not implemented");
}
function dyn_or(_tag, _lhs, _rhs) {
    throw new Error("Not implemented");
}
function dyn_eq(tag, lhs, rhs) {
    return deep_eq(lhs, rhs);
}
function dyn_neq(tag, lhs, rhs) {
    return !dyn_eq(tag, lhs, rhs);
}
function dyn_lt(_tag, _lhs, _rhs) {
    throw new Error("Not implemented");
}
function dyn_gt(_tag, _lhs, _rhs) {
    throw new Error("Not implemented");
}
function dyn_le(_tag, _lhs, _rhs) {
    throw new Error("Not implemented");
}
function dyn_ge(_tag, _lhs, _rhs) {
    throw new Error("Not implemented");
}
function veq(lhs, rhs) {
    return deep_eq(lhs, rhs);
}
function copy(val) {
    const v = val;
    if (val instanceof aptos.HexString) {
        // address & signer are immutable
        return val;
    }
    else if (typeof val === "boolean") {
        return val;
    }
    else if (val instanceof UnsignedInt) {
        return val.copy();
    }
    else if (val instanceof Array) {
        return val.map((ele) => copy(ele));
    }
    else if (v.typeTag instanceof StructTag$1) {
        let proto = Object();
        const structInfo = v.constructor;
        for (const field of structInfo.fields) {
            const fname = field.name;
            proto[fname] = copy(v[fname]);
        }
        let copied = new structInfo(proto, v.typeTag);
        return copied;
    }
    else {
        throw new Error(`Unreachable: ${val}`);
    }
}
function printerReplacer(key, val) {
    if (key === "typeTag" || key === "__app") {
        return undefined;
    }
    if (val instanceof aptos.HexString) {
        return val.toShortString();
    }
    else if (typeof val === "boolean") {
        return val;
    }
    else if (typeof val === "string") {
        return val;
    }
    else if (val instanceof UnsignedInt) {
        if (val instanceof U8) {
            return val.toJsNumber();
        }
        else {
            return val.value.toString();
        }
    }
    else if (val instanceof Array) {
        // optimize for U8[]?
        return val;
    }
    else if (val.typeTag instanceof StructTag$1) {
        // check for String
        const tag = val.typeTag;
        const tagFullname = tag.getFullname();
        if (tagFullname === "0x1::string::String") {
            const bytes = val.bytes;
            return u8str(bytes);
        }
        else if (tagFullname === "0x1::type_info::TypeInfo") {
            const account_address = val.account_address.toShortString();
            const module_name = u8str(val.module_name);
            const struct_name = u8str(val.struct_name);
            const type = `${account_address}::${module_name}::${struct_name}`;
            return {
                type,
                account_address,
                module_name,
                struct_name,
            };
        }
        else {
            return val;
        }
    }
    else {
        throw new Error(`Unreachable: ${val}`);
    }
}
function print(val) {
    console.log(JSON.stringify(val, printerReplacer, 2));
}
function set(lhs, rhs) {
    if (lhs instanceof aptos.HexString) {
        if (!(rhs instanceof aptos.HexString)) {
            throw new Error("Expect both lhs and rhs to be HexString!");
        }
        lhs.hexString = rhs.hexString;
    }
    else if (typeof lhs === "boolean") {
        throw new Error("Mutating boolean value by reference not supported");
    }
    else if (lhs instanceof UnsignedInt) {
        if (!(rhs instanceof UnsignedInt)) {
            throw new Error("Expect both lhs and rhs to be UnsignedInt!");
        }
        lhs.$set(rhs);
    }
    else if (lhs instanceof Array) {
        if (!(rhs instanceof Array)) {
            throw new Error("Expect both lhs and rhs to be array type!");
        }
        // clear then copy by value
        lhs.length = 0;
        for (const val of rhs) {
            lhs.push(copy(val));
        }
    }
    else if (lhs.typeTag instanceof StructTag$1) {
        // struct set
        const structInfo = lhs.constructor;
        for (const field of structInfo.fields) {
            lhs[field.name] = copy(rhs[field.name]);
        }
    }
}
function u8str(array) {
    const u8array = new Uint8Array(array.map((u) => u.toJsNumber()));
    return new TextDecoder().decode(u8array);
}
function strToU8(str) {
    const result = [];
    for (let i = 0; i < str.length; i++) {
        result.push(u8(str.charCodeAt(i)));
    }
    return result;
}
function payloadArg(val) {
    if (val instanceof UnsignedInt) {
        if (val instanceof U8) {
            return val.toJsNumber();
        }
        else if (val instanceof U64 || val instanceof U128) {
            return val.value.toString();
        }
        else {
            throw new Error("Only expect U8, U64, or U128 for integer types");
        }
    }
    else if (val instanceof aptos.HexString) {
        return val.toShortString();
    }
    else if (val.hexString) {
        return val.toShortString();
    }
    else if (typeof val === "boolean") {
        return val;
    }
    else if (val.typeTag instanceof StructTag$1) {
        const tag = val.typeTag;
        if (tag.address.toShortString() === "0x1" &&
            tag.module === "string" &&
            tag.name === "String") {
            const stringVal = val;
            const strVal = u8str(stringVal.bytes);
            return strVal;
        }
        else {
            throw new Error(`Unexpected struct type: ${tag.getFullname()}`);
        }
    }
    else if (val instanceof Array) {
        return val.map(payloadArg);
    }
    else {
        throw new Error(`Unexpected value type: ${typeof val}`);
    }
}
function u8ArrayArg(val) {
    const uint8array = new Uint8Array(Array.from(val.map((u) => u.toJsNumber())));
    return aptos.HexString.fromUint8Array(uint8array).hex();
}
function moveValueToOpenApiObject(val, typeTag) {
    if (val instanceof U8) {
        return val.toJsNumber();
    }
    else if (val instanceof U64 || val instanceof U128) {
        return val.value.toString();
    }
    else if (val instanceof aptos.HexString) {
        return val.hex();
    }
    // vector
    else if (val instanceof Array) {
        if (!(typeTag instanceof VectorTag)) {
            throw new Error("Expected a vector value");
        }
        // special handler for U8[]
        if (typeTag.elementType === exports.AtomicTypeTag.U8) {
            return u8ArrayArg(val);
        }
        return val.map((ele) => moveValueToOpenApiObject(ele, typeTag.elementType));
    }
    // object / struct
    else if (typeof val === "object") {
        if (!(typeTag instanceof StructTag$1)) {
            throw new Error("Expected a struct value");
        }
        // special handler for ASCII
        if (typeTag.getFullname() === "0x1::string::String") {
            const bytes = val.bytes;
            return u8str(bytes);
        }
        const result = new Object();
        const structInfo = val.constructor;
        for (const field of structInfo.fields) {
            const name = field.name;
            const fieldTag = substituteTypeParams(field.typeTag, typeTag.typeParams);
            result[name] = moveValueToOpenApiObject(val[field.name], fieldTag);
        }
        return result;
    }
    else {
        throw new Error("Unreachable");
    }
}

function parseStructProto(data, typeTag, repo, struct) {
    if (!(typeTag instanceof StructTag$1)) {
        throw new Error(`${struct.structName} expects a StructTag as typeTag but received: ${typeTag}`);
    }
    if (typeTag.address.toShortString() !== struct.moduleAddress.toShortString()) {
        throw new Error(`${struct.structName} expects a moduleAddress of ${struct.moduleAddress} but received: ${typeTag.address}.`);
    }
    if (typeTag.module !== struct.moduleName) {
        throw new Error(`${struct.structName} expects a moduleName of ${struct.moduleName} but received: ${typeTag.module}`);
    }
    if (typeTag.name !== struct.structName) {
        throw new Error(`${struct.structName} expects a struct name of "${struct.structName}" but received: ${typeTag.name}`);
    }
    if (typeof data !== "object") {
        // could be 0x1::string::String
        if (typeTag.address.toShortString() === "0x1" &&
            typeTag.module === "string" &&
            typeTag.name === "String") {
            // return the proto object directly
            const bytes = strToU8(data);
            const proto = { bytes };
            return proto;
        }
        throw new Error(`${struct.structName} expects data to be an object, but instead got: ${typeof data}`);
    }
    // check all keys exist
    let proto = {};
    for (const fieldDecl of struct.fields) {
        const fieldName = fieldDecl.name;
        if (!(fieldName in data)) {
            throw new Error(`${struct.structName} expects a field named ${fieldName} but it does not exist`);
        }
        // substitute TypeParamIdx with the actual typeParam
        const fieldTypeTag = substituteTypeParams(fieldDecl.typeTag, typeTag.typeParams);
        if (!fieldTypeTag) {
            console.log(JSON.stringify(typeTag.typeParams));
            console.log(JSON.stringify(fieldDecl.typeTag));
            throw new Error("BAD ParamIdx, see console log for details");
        }
        const parser = repo.getParserFromTypeTag(fieldTypeTag);
        if (!parser) {
            throw new Error(`Failed to find parser for ${fieldName} with type: ${fieldTypeTag}`);
        }
        const parsedValue = parser(data[fieldName], fieldTypeTag, repo);
        proto[fieldName] = parsedValue;
    }
    return proto;
}
function U8Parser(data, typeTag, _repo) {
    if (typeTag !== exports.AtomicTypeTag.U8) {
        throw new Error(`U8Parser cannot parse type: ${getTypeTagParamlessName(typeTag)}`);
    }
    if (typeof data !== "number") {
        throw new Error(`U8Parser expects number type as data but received: ${typeof data}`);
    }
    if (data < 0 || data > 255) {
        throw new Error(`U8Parser expects a number between 0 and 255, but received: ${data}`);
    }
    if (!Number.isInteger(data)) {
        throw new Error(`U8Parser expects an integer but received: ${data}`);
    }
    return new U8(bigInt__default["default"](data));
}
function U64Parser(data, typeTag, _repo) {
    if (typeTag !== exports.AtomicTypeTag.U64) {
        throw new Error(`U64Parser cannot parse type: ${getTypeTagParamlessName(typeTag)}`);
    }
    if (typeof data !== "string") {
        throw new Error(`U64Parser expects string type as data but received: ${typeof data}`);
    }
    return new U64(bigInt__default["default"](data));
}
function U128Parser(data, typeTag, _repo) {
    if (typeTag !== exports.AtomicTypeTag.U128) {
        throw new Error(`U128Parser cannot parse type: ${getTypeTagParamlessName(typeTag)}`);
    }
    if (typeof data !== "string") {
        throw new Error(`U128Parser expects string type as data but received: ${typeof data}`);
    }
    return new U128(bigInt__default["default"](data));
}
function BoolParser(data, typeTag, _repo) {
    if (typeTag !== exports.AtomicTypeTag.Bool) {
        throw new Error(`BoolParser cannot parse type: ${getTypeTagParamlessName(typeTag)}`);
    }
    if (typeof data !== "boolean") {
        throw new Error(`BoolParser expects bool type as data but received: ${typeof data}`);
    }
    return data;
}
function AddressParser(data, typeTag, _repo) {
    if (typeTag !== exports.AtomicTypeTag.Address) {
        throw new Error(`AddressParser cannot parse type: ${getTypeTagParamlessName(typeTag)}`);
    }
    if (typeof data !== "string") {
        throw new Error(`AddressParser expects string type as data but received: ${typeof data}`);
    }
    return new aptos.HexString(data);
}
class AptosVectorU8 {
    constructor(input) {
        if (input instanceof Uint8Array) {
            this.u8Array = input;
        }
        else if (typeof input === "string") {
            this.u8Array = new TextEncoder().encode(input);
        }
        else {
            this.u8Array = new Uint8Array(input);
        }
    }
    toString() {
        return new TextDecoder().decode(this.u8Array);
    }
    toHexString() {
        return aptos.HexString.fromUint8Array(this.u8Array);
    }
    hex() {
        return aptos.HexString.fromUint8Array(this.u8Array).hex();
    }
    asNumbers() {
        return Array.from(this.u8Array);
    }
}
function numbersOrStringToHexString(input) {
    if (typeof input === "string") {
        return aptos.HexString.fromUint8Array(new TextEncoder().encode(input));
    }
    else if (input instanceof Uint8Array) {
        return aptos.HexString.fromUint8Array(input);
    }
    else {
        // number[]
        return aptos.HexString.fromUint8Array(new Uint8Array(input));
    }
}
function VectorParser(data, typeTag, repo) {
    if (!(typeTag instanceof VectorTag)) {
        throw new Error(`VectorParser cannot parse type: ${getTypeTagParamlessName(typeTag)}`);
    }
    const elementType = typeTag.elementType;
    if (elementType === exports.AtomicTypeTag.U8) {
        if (typeof data !== "string") {
            throw new Error(`Expected string type for U8[] but received: ${typeof data}`);
        }
        const hex = new aptos.HexString(data);
        return Array.from(hex.toUint8Array()).map((u) => u8(u));
    }
    if (!(data instanceof Array)) {
        throw new Error(`VectorParser expects Array type as data but received: ${typeof data}`);
    }
    const elementTypeParamlessName = getTypeTagParamlessName(elementType);
    const elementParser = repo.getParserFromParamlessName(elementTypeParamlessName);
    if (!elementParser) {
        throw new Error(`No parser exists for type: ${elementTypeParamlessName}`);
    }
    const vector = [];
    for (const element of data) {
        vector.push(elementParser(element, elementType, repo));
    }
    return vector;
}
class AptosParserRepo {
    constructor() {
        this.paramlessNameToParser = {};
    }
    loadResource(client, address, structTsType, typeParams) {
        return __awaiter(this, void 0, void 0, function* () {
            // make a concrete typeTag
            if (structTsType.typeParameters.length !== typeParams.length) {
                throw new Error(`Expected ${structTsType.typeParameters.length} type parameters but got ${typeParams.length}`);
            }
            const typeTag = new StructTag$1(structTsType.moduleAddress, structTsType.moduleName, structTsType.structName, typeParams);
            const resource = yield client.getAccountResource(address, typeTag.getAptosMoveTypeTag());
            const proto = parseStructProto(resource.data, typeTag, this, structTsType);
            return new structTsType(proto, typeTag);
        });
    }
    loadEvents(client, address, containerTypeTag, field, query) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(containerTypeTag instanceof StructTag$1)) {
                throw new Error(`Event handler container struct should be a struct, but received: ${getTypeTagParamlessName(containerTypeTag)}`);
            }
            const events = yield client.getEventsByEventHandle(address, containerTypeTag.getAptosMoveTypeTag(), field, query);
            return events.map((e) => {
                const tag = parseTypeTagOrThrow(e.type);
                return this.parse(e.data, tag);
            });
        });
    }
    parse(data, typeTag) {
        const paramlessName = getTypeTagParamlessName(typeTag);
        const parser = this.paramlessNameToParser[paramlessName];
        if (!parser) {
            throw new Error(`No parser registered for type: ${paramlessName}`);
        }
        return parser(data, typeTag, this);
    }
    getParserFromParamlessName(paramlessName) {
        const parser = this.paramlessNameToParser[paramlessName];
        if (parser) {
            return parser;
        }
        return null;
    }
    getParserFromTypeTag(typeTag) {
        const paramlessName = getTypeTagParamlessName(typeTag);
        return this.getParserFromParamlessName(paramlessName);
    }
    addParser(paramlessName, parser) {
        this.paramlessNameToParser[paramlessName] = parser;
    }
    addDefaultParsers() {
        // load the defaults
        this.addParser("bool", BoolParser);
        this.addParser("u8", U8Parser);
        this.addParser("u64", U64Parser);
        this.addParser("u128", U128Parser);
        this.addParser("address", AddressParser);
        this.addParser("vector", VectorParser);
    }
}

/*
BCS serialization of Move values
*/
function serializeVector(serializer, v, elementTag) {
    if (!(v instanceof Array)) {
        throw new Error("Expected v to be a vector/array");
    }
    serializer.serializeU32AsUleb128(v.length);
    for (const element of v) {
        serializeMoveValue(serializer, element, elementTag);
    }
}
function serializeStruct(serializer, v, tag) {
    if (typeof v !== "object") {
        throw new Error("serializeStruct expected an object input as v");
    }
    const ctor = v.constructor;
    if (!ctor) {
        throw new Error("Struct value should have a constructor!");
    }
    const structDef = ctor;
    for (const field of structDef.fields) {
        const concreteTag = substituteTypeParams(field.typeTag, tag.typeParams);
        serializeMoveValue(serializer, v[field.name], concreteTag);
    }
}
function addressToUint8Array(h) {
    const noPrefix = h.noPrefix();
    // build a hexString of 64 hexadecimal digits
    const full = "0".repeat(64 - noPrefix.length) + noPrefix;
    const buf = Buffer.from(full, "hex");
    return Uint8Array.from(buf);
}
function serializeMoveValue(serializer, v, tag) {
    if (tag === exports.AtomicTypeTag.Address) {
        if (!(v instanceof aptos.HexString)) {
            throw new Error("Expected value to be HexString");
        }
        serializer.serializeFixedBytes(addressToUint8Array(v));
    }
    else if (tag === exports.AtomicTypeTag.Signer) {
        throw new Error("Cannot serialize signer!");
    }
    else if (tag === exports.AtomicTypeTag.Bool) {
        if (!(typeof v === "boolean")) {
            throw new Error("Expected value to be boolean");
        }
        serializer.serializeBool(v);
    }
    else if (tag === exports.AtomicTypeTag.U8) {
        if (!(v instanceof U8)) {
            throw new Error("Expected value to be U8");
        }
        serializer.serializeU8(v.toJsNumber());
    }
    else if (tag === exports.AtomicTypeTag.U64) {
        if (!(v instanceof U64)) {
            throw new Error("Expected value to be U64");
        }
        serializer.serializeU64(v.toBigInt());
    }
    else if (tag === exports.AtomicTypeTag.U128) {
        if (!(v instanceof U128)) {
            throw new Error("Expected value to be U128");
        }
        serializer.serializeU128(v.toBigInt());
    }
    else if (tag instanceof VectorTag) {
        serializeVector(serializer, v, tag.elementType);
    }
    else if (tag instanceof StructTag$1) {
        serializeStruct(serializer, v, tag);
    }
    else if (v instanceof TypeParamIdx) {
        throw new Error("BCS serialization expected concrete TypeTag but received TypeParamIdx");
    }
    else {
        throw new Error("Unreachable");
    }
}
function serializeMoveValueWithoutTag(serializer, value) {
    if (value instanceof U8) {
        serializeMoveValue(serializer, value, exports.AtomicTypeTag.U8);
    }
    else if (value instanceof U64) {
        serializeMoveValue(serializer, value, exports.AtomicTypeTag.U64);
    }
    else if (value instanceof U128) {
        serializeMoveValue(serializer, value, exports.AtomicTypeTag.U128);
    }
    else if (typeof value === "boolean") {
        serializeMoveValue(serializer, value, exports.AtomicTypeTag.Bool);
    }
    else if (value instanceof aptos.HexString) {
        serializeMoveValue(serializer, value, exports.AtomicTypeTag.Address);
    }
    else if (value.hexString) {
        const addr = new aptos.HexString(value.hex());
        serializeMoveValue(serializer, addr, exports.AtomicTypeTag.Address);
    }
    // struct
    else if (value.typeTag instanceof StructTag$1) {
        const tag = value.typeTag;
        serializeStruct(serializer, value, tag);
    }
    // vector
    else if (value instanceof Array) {
        serializer.serializeU32AsUleb128(value.length);
        for (const element of value) {
            serializeMoveValueWithoutTag(serializer, element);
        }
    }
    else {
        throw new Error(`Unrecognized value type: ${value}`);
    }
}
/*
BCS deserialization of Move values
*/
function deserializeMoveValue(deserializer, tag) {
    if (tag === exports.AtomicTypeTag.Address) {
        const bytes = deserializer.deserializeFixedBytes(32);
        return aptos.HexString.fromUint8Array(bytes);
    }
    else if (tag === exports.AtomicTypeTag.Signer) {
        throw new Error("Cannot deserialize signer!");
    }
    else if (tag === exports.AtomicTypeTag.Bool) {
        const result = deserializer.deserializeBool();
        return result;
    }
    else if (tag === exports.AtomicTypeTag.U8) {
        const result = deserializer.deserializeU8();
        return u8(result.toString());
    }
    else if (tag === exports.AtomicTypeTag.U64) {
        const result = deserializer.deserializeU64();
        return u64(result.toString());
    }
    else if (tag === exports.AtomicTypeTag.U128) {
        const result = deserializer.deserializeU128();
        return u128(result.toString());
    }
    else if (tag instanceof VectorTag) {
        const length = deserializer.deserializeUleb128AsU32();
        const result = [];
        for (let i = 0; i < length; i++) {
            result.push(deserializeMoveValue(deserializer, tag.elementType));
        }
        return result;
    }
    else if (tag instanceof StructTag$1) {
        if (tag instanceof SimpleStructTag) {
            const structInfo = tag.structInfo;
            const proto = {};
            for (const field of structInfo.fields) {
                const concreteTag = substituteTypeParams(field.typeTag, tag.typeParams);
                const fieldVal = deserializeMoveValue(deserializer, concreteTag);
                proto[field.name] = fieldVal;
            }
            return new structInfo(proto, tag);
        }
        else {
            throw new Error("Not implemented. Deserialization only works for SimpleStructTag");
        }
    }
    else {
        throw new Error("Unreachable");
    }
}

/*
native functions for BCS serialization/deserialization
*/
function std_bcs_to_bytes(v, $c, tags) {
    if (tags.length !== 1) {
        throw new Error(`Expected 1 TypeTag in tags but received: ${tags.length}`);
    }
    const serializer = new aptos.BCS.Serializer();
    serializeMoveValue(serializer, v, tags[0]);
    const array = Array.from(serializer.getBytes());
    return array.map((u) => new U8(bigInt__default["default"](u)));
}
function aptos_framework_util_from_bytes(bytes, $c, tags) {
    if (tags.length !== 1) {
        throw new Error(`Expected 1 TypeTag in tags but received: ${tags.length}`);
    }
    const array = new Uint8Array(bytes.map((u) => u.toJsNumber()));
    const deserializer = new aptos.BCS.Deserializer(array);
    const result = deserializeMoveValue(deserializer, tags[0]);
    return result;
}
function aptos_std_any_from_bytes(bytes, $c, tags) {
    if (tags.length !== 1) {
        throw new Error(`Expected 1 TypeTag in tags but received: ${tags.length}`);
    }
    const array = new Uint8Array(bytes.map((u) => u.toJsNumber()));
    const deserializer = new aptos.BCS.Deserializer(array);
    const result = deserializeMoveValue(deserializer, tags[0]);
    return result;
}
/*
native functions from Std
*/
function aptos_std_debug_print(v, $c, _) {
    console.log(JSON.stringify(v, null, 2));
}
function aptos_std_debug_print_stack_trace($c) {
    // NOP
}
function aptos_framework_event_write_to_event_store(guid, count, msg, $c, _tags) {
    // FIXME: should probably allow some callback/prints??
    // NOP
}
function aptos_std_event_write_to_event_store(guid, count, msg, $c, _tags) {
    // FIXME: should probably allow some callback/prints??
    // NOP
}
function aptos_std_multi_ed25519_signature_verify_strict_internal(multisignature, public_key, message, $c) {
    throw new Error("Not implemented");
}
function aptos_std_multi_ed25519_public_key_validate_internal(bytes, $c) {
    throw new Error("Not implemented");
}
function aptos_std_from_bcs_from_bytes(bytes, $c, $p) {
    return aptos_framework_util_from_bytes(bytes, $c, $p);
}
function aptos_std_aptos_hash_keccak256(bytes, $c) {
    throw new Error("Not implemented");
}
function aptos_std_aptos_hash_ripemd160_internal(bytes, $c) {
    throw new Error("Not implemented");
}
function aptos_std_aptos_hash_sha2_512_internal(bytes, $c) {
    throw new Error("Not implemented");
}
function aptos_std_aptos_hash_sip_hash(bytes, $c) {
    throw new Error("Not implemented");
}
function aptos_std_secp256k1_ecdsa_recover_internal(message, recovery_id, signature, $c) {
    throw new Error("Not implemented");
}
function std_hash_sha2_256(data, $c) {
    const dataBuffer = Buffer.from(data.map((u) => u.value.toJSNumber()));
    const outputBuffer = new sha__namespace.sha256().update(dataBuffer).digest();
    return Array.from(outputBuffer).map((u) => new U8(bigInt__default["default"](u)));
}
function std_hash_sha3_256(data, $c) {
    const dataBuffer = Buffer.from(data.map((u) => u.value.toJSNumber()));
    const outputBuffer = new sha3.SHA3(256).update(dataBuffer).digest();
    return Array.from(outputBuffer).map((u) => new U8(bigInt__default["default"](u)));
}
function std_signer_borrow_address(s, $c) {
    return s;
}
function std_string_internal_check_utf8(v, $c) {
    const bytes = new Uint8Array(v.map((u) => u.toJsNumber()));
    const decoder = new TextDecoder("utf-8", { fatal: true });
    try {
        decoder.decode(bytes);
        return true;
    }
    catch (e) {
        return false;
    }
}
function std_string_internal_is_char_boundary(v, i, $c) {
    if (i.toJsNumber() > v.length) {
        return false;
    }
    return std_string_internal_check_utf8(v.slice(0, i.toJsNumber()));
}
function std_string_internal_sub_string(v, i, j, $c) {
    const [ii, jj] = [i.toJsNumber(), j.toJsNumber()];
    if (!std_string_internal_is_char_boundary(v, i)) {
        throw new Error(`sub_string start index ${ii} is not utf8 char boundary`);
    }
    if (!std_string_internal_is_char_boundary(v, j)) {
        throw new Error(`sub_string end index ${jj} is not utf8 char boundary`);
    }
    if (ii > jj) {
        throw new Error(`Substring start index ${ii} greater than ending index ${jj}`);
    }
    return v.slice(ii, jj);
}
function std_string_internal_index_of(v, r, $c) {
    const vv = new Uint8Array(v.map((u) => u.toJsNumber()));
    const rr = new Uint8Array(r.map((u) => u.toJsNumber()));
    const decoder = new TextDecoder("utf-8", { fatal: true });
    const vStr = decoder.decode(vv);
    const rStr = decoder.decode(rr);
    const idx = vStr.indexOf(rStr);
    return u64(idx === -1 ? v.length : idx);
}
function std_unit_test_create_signers_for_testing(numSigners, $c) {
    const result = [];
    for (let i = 0; i < numSigners.value.toJSNumber(); i++) {
        result.push(new aptos.HexString((0x1000 + i).toString(16)));
    }
    return result;
}
function std_vector_empty($c, tags) {
    if (tags.length !== 1) {
        throw new Error(`Incorrect number of type arguments: ${tags.length}`);
    }
    return [];
}
function std_vector_length(vec, $c, tags) {
    if (tags.length !== 1) {
        throw new Error(`Incorrect number of type arguments: ${tags.length}`);
    }
    return new U64(bigInt__default["default"](vec.length));
}
function std_vector_borrow(vec, i, $c, tags) {
    if (tags.length !== 1) {
        throw new Error(`Incorrect number of type arguments: ${tags.length}`);
    }
    const idx = i.value.toJSNumber();
    if (idx >= vec.length) {
        throw new Error(`Index out of bounds: ${idx} >= ${vec.length}`);
    }
    return vec[idx];
}
function std_vector_push_back(vec, e, $c, tags) {
    if (tags.length !== 1) {
        throw new Error(`Incorrect number of type arguments: ${tags.length}`);
    }
    vec.push(e);
}
function std_vector_borrow_mut(vec, i, $c, tags) {
    if (tags.length !== 1) {
        throw new Error(`Incorrect number of type arguments: ${tags.length}`);
    }
    const idx = i.value.toJSNumber();
    if (idx >= vec.length) {
        throw new Error(`Index out of bounds: ${idx} >= ${vec.length}`);
    }
    // FIXME: we should probably wrap &mut in a MutRef object with a $set method
    return vec[idx];
}
function std_vector_pop_back(vec, $c, tags) {
    if (tags.length !== 1) {
        throw new Error(`Incorrect number of type arguments: ${tags.length}`);
    }
    if (vec.length === 0) {
        throw new Error("Trying to pop vector with 0 length");
    }
    return vec.pop();
}
function std_vector_destroy_empty(vec, $c, tags) {
    if (tags.length !== 1) {
        throw new Error(`Incorrect number of type arguments: ${tags.length}`);
    }
    if (vec.length !== 0) {
        throw new Error("Vector is not empty!");
    }
}
function std_vector_swap(vec, i, j, $c, tags) {
    if (tags.length !== 1) {
        throw new Error(`Incorrect number of type arguments: ${tags.length}`);
    }
    const idx = i.value.toJSNumber();
    const jdx = j.value.toJSNumber();
    if (idx >= vec.length) {
        throw new Error(`Index out of bounds: ${idx} >= ${vec.length}`);
    }
    if (jdx >= vec.length) {
        throw new Error(`Index out of bounds: ${jdx} >= ${vec.length}`);
    }
    [vec[idx], vec[jdx]] = [vec[jdx], vec[idx]];
}
/*
native functions from AptosFramework
*/
function aptos_framework_aggregator_add(aggregator, value, $c) {
    throw new Error("Not Implemented");
}
function aptos_framework_aggregator_destroy(aggregator, $c) {
    throw new Error("Not Implemented");
}
function aptos_framework_aggregator_read(aggregator, $c) {
    throw new Error("Not Implemented");
}
function aptos_framework_aggregator_sub(aggregator, value, $c) {
    throw new Error("Not Implemented");
}
function aptos_framework_account_create_address(bytes, $c) {
    if (bytes.length !== 32) {
        throw new Error(`bytes must have length of 32, but got ${bytes.length}`);
    }
    const bytesArray = new Uint8Array(bytes.map((u) => u.value.toJSNumber()));
    return aptos.HexString.fromUint8Array(bytesArray);
}
function aptos_framework_genesis_create_signer(addr, $c) {
    return aptos_framework_account_create_signer(addr);
}
function aptos_framework_account_create_signer(addr, $c) {
    // FIXME
    // yep, our runtime does not distinguish between address and signer. This might get us in trouble down the road...
    // but for now just use this
    return addr;
}
new aptos.HexString("0x1");
[
    {
        name: "name",
        typeTag: new StructTag$1(new aptos.HexString("0x1"), "string", "String", []),
    },
    {
        name: "source",
        typeTag: new StructTag$1(new aptos.HexString("0x1"), "string", "String", []),
    },
    { name: "source_map", typeTag: new VectorTag(exports.AtomicTypeTag.U8) },
    { name: "abi", typeTag: new VectorTag(exports.AtomicTypeTag.U8) },
];
class PackageMetadata {
    constructor(proto, typeTag) {
        this.typeTag = typeTag;
        this.__app = null;
        this.name = proto["name"];
        this.upgrade_policy = proto["upgrade_policy"];
        this.manifest = proto["manifest"];
        this.modules = proto["modules"];
    }
    static PackageMetadataParser(data, typeTag, repo) {
        const proto = parseStructProto(data, typeTag, repo, PackageMetadata);
        return new PackageMetadata(proto, typeTag);
    }
    loadFullState(app) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
}
PackageMetadata.moduleAddress = new aptos.HexString("0x1");
PackageMetadata.moduleName = "code";
PackageMetadata.structName = "PackageMetadata";
PackageMetadata.typeParameters = [];
PackageMetadata.fields = [
    {
        name: "name",
        typeTag: new StructTag$1(new aptos.HexString("0x1"), "string", "String", []),
    },
    {
        name: "upgrade_policy",
        typeTag: new StructTag$1(new aptos.HexString("0x1"), "code", "UpgradePolicy", []),
    },
    {
        name: "manifest",
        typeTag: new StructTag$1(new aptos.HexString("0x1"), "string", "String", []),
    },
    {
        name: "modules",
        typeTag: new VectorTag(new StructTag$1(new aptos.HexString("0x1"), "code", "ModuleMetadata", [])),
    },
];
class UpgradePolicy {
    constructor(proto, typeTag) {
        this.typeTag = typeTag;
        this.__app = null;
        this.policy = proto["policy"];
    }
    static UpgradePolicyParser(data, typeTag, repo) {
        const proto = parseStructProto(data, typeTag, repo, UpgradePolicy);
        return new UpgradePolicy(proto, typeTag);
    }
    loadFullState(app) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
}
UpgradePolicy.moduleAddress = new aptos.HexString("0x1");
UpgradePolicy.moduleName = "code";
UpgradePolicy.structName = "UpgradePolicy";
UpgradePolicy.typeParameters = [];
UpgradePolicy.fields = [
    { name: "policy", typeTag: exports.AtomicTypeTag.U8 },
];
function aptos_framework_code_request_publish(owner, expected_modules, bundle, policy, $c) {
    throw new Error("Not Implemented");
}
function aptos_framework_code_request_publish_with_allowed_deps(owner, expected_modules, allowed_deps, bundle, policy, $c) {
    throw new Error("Not Implemented");
}
function u8ArrayToKeyString(u8array) {
    return u8array.map((u) => u.value.toJSNumber().toString(16)).join();
}
function aptos_std_bls12381_aggregate_pubkeys_internal(pubkeys, $c) {
    throw new Error("Not implemented");
}
function aptos_std_bls12381_aggregate_signatures_internal(signatures, $c) {
    throw new Error("Not implemented");
}
function aptos_std_bls12381_validate_pubkey_internal(pubkey, $c) {
    throw new Error("Not implemented");
}
function aptos_std_bls12381_signature_subgroup_check_internal(signature, $c) {
    throw new Error("Not implemented");
}
function aptos_std_bls12381_verify_aggregate_signature_internal(a, b, c, $c) {
    throw new Error("Not implemented");
}
function aptos_std_bls12381_verify_multisignature_internal(a, b, c, $c) {
    throw new Error("Not implemented");
}
function aptos_std_bls12381_verify_normal_signature_internal(signature, public_key, mesage, $c) {
    throw new Error("Not implemented");
}
function aptos_std_bls12381_verify_proof_of_possession_internal(public_key, proof_of_posession, $c) {
    throw new Error("Not implemented");
}
function aptos_std_bls12381_verify_signature_share_internal(a, b, c, $c) {
    throw new Error("Not implemented");
}
function aptos_std_ed25519_public_key_validate_internal(pubkey, $c) {
    throw new Error("Not implemented");
}
function aptos_std_ed25519_signature_verify_strict_internal(signature, pubkey, message, $c) {
    const ec = new elliptic__namespace.eddsa("ed25519");
    const keyString = u8ArrayToKeyString(pubkey);
    const key = ec.keyFromPublic(keyString);
    return key.verify(u8ArrayToKeyString(message), u8ArrayToKeyString(signature));
}
function aptos_std_secp256k1_ecdsa_recover(message, recovery_id, signature, $c) {
    throw new Error("Not implemented");
}
function aptos_std_table_new_table_handle($c, tags) {
    return $c.table_new_handle();
}
function aptos_std_table_add_box(table, key, value, $c, tags) {
    return $c.table_add_box(table, key, value);
}
function aptos_std_table_borrow_box(table, key, $c, tags) {
    return $c.table_borrow_box(table, key);
}
function aptos_std_table_borrow_box_mut(table, key, $c, tags) {
    return $c.table_borrow_box_mut(table, key);
}
function aptos_std_table_contains_box(table, key, $c, tags) {
    return $c.table_contains_box(table, key);
}
function aptos_std_table_remove_box(table, key, $c, tags) {
    return $c.table_remove_box(table, key);
}
function aptos_std_table_destroy_empty_box(table, $c, tags) {
    return $c.table_destroy_empty_box(table);
}
function aptos_std_table_drop_unchecked_box(table, $c, tags) {
    return $c.table_drop_unchecked_box(table);
}
function aptos_framework_transaction_context_get_script_hash($c) {
    throw new Error("Not Implemented");
}
class ActualUsage {
    constructor(proto, typeTag) {
        this.typeTag = typeTag;
        this.__app = null;
        this.items = proto["items"];
        this.bytes = proto["bytes"];
    }
    static UsageParser(data, typeTag, repo) {
        const proto = parseStructProto(data, typeTag, repo, ActualUsage);
        return new ActualUsage(proto, typeTag);
    }
    static getTag() {
        return new StructTag$1(ActualUsage.moduleAddress, ActualUsage.moduleName, "Usage", []);
    }
    loadFullState(app) {
        return __awaiter(this, void 0, void 0, function* () {
            this.__app = app;
        });
    }
}
ActualUsage.moduleAddress = new aptos.HexString("0x1");
ActualUsage.moduleName = "state_storage";
ActualUsage.structName = "Usage";
ActualUsage.typeParameters = [];
ActualUsage.fields = [
    { name: "items", typeTag: exports.AtomicTypeTag.U64 },
    { name: "bytes", typeTag: exports.AtomicTypeTag.U64 },
];
function aptos_framework_state_storage_get_state_storage_usage_only_at_epoch_beginning($c) {
    throw new Error("Not Implemented");
}
class ActualAggregator {
    constructor(proto, typeTag) {
        this.typeTag = typeTag;
        this.__app = null;
        this.handle = proto["handle"];
        this.key = proto["key"];
        this.limit = proto["limit"];
    }
    static AggregatorParser(data, typeTag, repo) {
        const proto = parseStructProto(data, typeTag, repo, ActualAggregator);
        return new ActualAggregator(proto, typeTag);
    }
    static getTag() {
        return new StructTag$1(ActualAggregator.moduleAddress, ActualAggregator.moduleName, "Aggregator", []);
    }
    loadFullState(app) {
        return __awaiter(this, void 0, void 0, function* () {
            this.__app = app;
        });
    }
}
ActualAggregator.moduleAddress = new aptos.HexString("0x1");
ActualAggregator.moduleName = "aggregator";
ActualAggregator.structName = "Aggregator";
ActualAggregator.typeParameters = [];
ActualAggregator.fields = [
    { name: "handle", typeTag: exports.AtomicTypeTag.Address },
    { name: "key", typeTag: exports.AtomicTypeTag.Address },
    { name: "limit", typeTag: exports.AtomicTypeTag.U128 },
];
function aptos_framework_aggregator_factory_new_aggregator(p1, p2, p3) {
    throw new Error("Not Implemented");
}
class ActualTypeInfoClass {
    constructor(proto, typeTag) {
        this.typeTag = typeTag;
        this.__app = null;
        this.account_address = proto["account_address"];
        this.module_name = proto["module_name"];
        this.struct_name = proto["struct_name"];
    }
    typeFullname() {
        return `${this.account_address.toShortString()}::${u8str(this.module_name)}::${u8str(this.struct_name)}`;
    }
    toTypeTag() {
        return parseTypeTagOrThrow(this.typeFullname());
    }
    moduleName() {
        return u8str(this.module_name);
    }
    structName() {
        return u8str(this.struct_name);
    }
    loadFullState(app) {
        return Promise.resolve();
    }
}
ActualTypeInfoClass.moduleAddress = new aptos.HexString("0x1");
ActualTypeInfoClass.moduleName = "type_info";
ActualTypeInfoClass.structName = "TypeInfo";
ActualTypeInfoClass.typeParameters = [];
ActualTypeInfoClass.fields = [
    { name: "account_address", typeTag: exports.AtomicTypeTag.Address },
    { name: "module_name", typeTag: new VectorTag(exports.AtomicTypeTag.U8) },
    { name: "struct_name", typeTag: new VectorTag(exports.AtomicTypeTag.U8) },
];
class ActualStringClass {
    constructor(proto, typeTag) {
        this.typeTag = typeTag;
        this.__app = null;
        this.bytes = proto["bytes"];
    }
    static StringParser(data, typeTag, repo) {
        const proto = parseStructProto(data, typeTag, repo, ActualStringClass);
        return new ActualStringClass(proto, typeTag);
    }
    str() {
        return u8str(this.bytes);
    }
    loadFullState(app) {
        return Promise.resolve();
    }
}
ActualStringClass.moduleAddress = new aptos.HexString("0x1");
ActualStringClass.moduleName = "string";
ActualStringClass.structName = "String";
ActualStringClass.typeParameters = [];
ActualStringClass.fields = [
    { name: "bytes", typeTag: new VectorTag(exports.AtomicTypeTag.U8) },
];
function stringToU8Array(val) {
    return Array.from(new TextEncoder().encode(val)).map((u) => new U8(bigInt__default["default"](u)));
}
function aptos_std_type_info_type_of($c, tags) {
    if (tags.length !== 1) {
        throw new Error(`Expect 1 typetag, but received: ${tags.length}`);
    }
    const tag = tags[0];
    if (!(tag instanceof StructTag$1)) {
        throw new Error("type_of requires Struct type as type argument");
    }
    const struct_name = tag.typeParams.length > 0
        ? `${tag.name}::${getTypeParamsString(tag.typeParams)}`
        : tag.name;
    const newTag = new StructTag$1(new aptos.HexString("0x1"), "TypeInfo", "TypeInfo", []);
    return new ActualTypeInfoClass({
        account_address: tag.address,
        module_name: stringToU8Array(tag.module),
        struct_name: stringToU8Array(struct_name),
    }, newTag);
}
function aptos_std_type_info_type_name($c, tags) {
    if (tags.length !== 1) {
        throw new Error(`Expect 1 typetag, but received: ${tags.length}`);
    }
    const tag = tags[0];
    const newTag = new StructTag$1(new aptos.HexString("0x1"), "string", "String", []);
    const name = getTypeTagFullname(tag);
    return new ActualStringClass({
        bytes: strToU8(name),
    }, newTag);
}
function aptos_std_type_info_chain_id_internal($c) {
    throw new Error("Not Implemented");
}

// Copyright (c) Aptos
const { TypeTagBool, TypeTagU8, TypeTagU64, TypeTagU128, TypeTagAddress, AccountAddress: AccountAddress$1, TypeTagVector, TypeTagStruct, StructTag, Identifier: Identifier$1, TransactionArgumentBool, TransactionArgumentU64, TransactionArgumentU128, TransactionArgumentAddress, TransactionArgumentU8, TransactionArgumentU8Vector, } = aptos.TxnBuilderTypes;
function bail(message) {
    throw new Error(message);
}
function isWhiteSpace(c) {
    if (c.match(/\s/)) {
        return true;
    }
    return false;
}
function isValidAlphabetic(c) {
    if (c.match(/[_A-Za-z0-9]/g)) {
        return true;
    }
    return false;
}
// Returns Token and Token byte size
function nextToken(tagStr, pos) {
    const c = tagStr[pos];
    if (c === ":") {
        if (tagStr.slice(pos, pos + 2) === "::") {
            return [["COLON", "::"], 2];
        }
        bail("Unrecognized token.");
    }
    else if (c === "<") {
        return [["LT", "<"], 1];
    }
    else if (c === ">") {
        return [["GT", ">"], 1];
    }
    else if (c === ",") {
        return [["COMMA", ","], 1];
    }
    else if (isWhiteSpace(c)) {
        let res = "";
        for (let i = pos; i < tagStr.length; i += 1) {
            const char = tagStr[i];
            if (isWhiteSpace(char)) {
                res = `${res}${char}`;
            }
            else {
                break;
            }
        }
        return [["SPACE", res], res.length];
    }
    else if (isValidAlphabetic(c)) {
        let res = "";
        for (let i = pos; i < tagStr.length; i += 1) {
            const char = tagStr[i];
            if (isValidAlphabetic(char)) {
                res = `${res}${char}`;
            }
            else {
                break;
            }
        }
        return [["IDENT", res], res.length];
    }
    throw new Error("Unrecognized token.");
}
function tokenize(tagStr) {
    let pos = 0;
    const tokens = [];
    while (pos < tagStr.length) {
        const [token, size] = nextToken(tagStr, pos);
        if (token[0] !== "SPACE") {
            tokens.push(token);
        }
        pos += size;
    }
    return tokens;
}
/**
 * Parser to parse a type tag string
 */
class TypeTagParser {
    constructor(tagStr) {
        this.tokens = tokenize(tagStr);
    }
    consume(targetToken) {
        const token = this.tokens.shift();
        if (!token || token[1] !== targetToken) {
            bail("Invalid type tag.");
        }
    }
    parseCommaList(endToken, allowTraillingComma) {
        const res = [];
        if (this.tokens.length <= 0) {
            bail("Invalid type tag.");
        }
        while (this.tokens[0][1] !== endToken) {
            res.push(this.parseTypeTag());
            if (this.tokens.length > 0 && this.tokens[0][1] === endToken) {
                break;
            }
            this.consume(",");
            if (this.tokens.length > 0 && this.tokens[0][1] === endToken && allowTraillingComma) {
                break;
            }
            if (this.tokens.length <= 0) {
                bail("Invalid type tag.");
            }
        }
        return res;
    }
    parseTypeTag() {
        if (this.tokens.length === 0) {
            bail("Invalid type tag.");
        }
        // Pop left most element out
        // @ts-ignore
        const [tokenTy, tokenVal] = this.tokens.shift();
        if (tokenVal === "u8") {
            return new TypeTagU8();
        }
        if (tokenVal === "u64") {
            return new TypeTagU64();
        }
        if (tokenVal === "u128") {
            return new TypeTagU128();
        }
        if (tokenVal === "bool") {
            return new TypeTagBool();
        }
        if (tokenVal === "address") {
            return new TypeTagAddress();
        }
        if (tokenVal === "vector") {
            this.consume("<");
            const res = this.parseTypeTag();
            this.consume(">");
            return new TypeTagVector(res);
        }
        if (tokenTy === "IDENT" && (tokenVal.startsWith("0x") || tokenVal.startsWith("0X"))) {
            const address = tokenVal;
            this.consume("::");
            const [moduleTokenTy, module] = this.tokens.shift();
            if (moduleTokenTy !== "IDENT") {
                bail("Invalid type tag.");
            }
            this.consume("::");
            const [nameTokenTy, name] = this.tokens.shift();
            if (nameTokenTy !== "IDENT") {
                bail("Invalid type tag.");
            }
            let tyTags = [];
            // Check if the struct has ty args
            if (this.tokens.length > 0 && this.tokens[0][1] === "<") {
                this.consume("<");
                tyTags = this.parseCommaList(">", true);
                this.consume(">");
            }
            const structTag = new StructTag(AccountAddress$1.fromHex(address), new Identifier$1(module), new Identifier$1(name), tyTags);
            return new TypeTagStruct(structTag);
        }
        throw new Error("Invalid type tag.");
    }
}

const { AccountAddress, Identifier, ModuleId, EntryFunction } = aptos.TxnBuilderTypes;
function buildPayload(moduleAddress, moduleName, funcName, typeArguments, args, isJSON = false) {
    if (isJSON) {
        // JSON
        return {
            type: "entry_function_payload",
            function: `${moduleAddress.toShortString()}::${moduleName}::${funcName}`,
            type_arguments: typeArguments,
            arguments: args.map((v) => payloadArg(v)),
        };
    }
    else {
        // BCS
        const bytes = args.map((arg) => {
            const serializer = new aptos.BCS.Serializer();
            serializeMoveValueWithoutTag(serializer, arg);
            return serializer.getBytes();
        });
        const scriptFunction = new EntryFunction(new ModuleId(new AccountAddress(moduleAddress.toUint8Array()), new Identifier(moduleName)), new Identifier(funcName), typeArguments.map((str) => new TypeTagParser(str).parseTypeTag()), bytes);
        return new aptos.TxnBuilderTypes.TransactionPayloadEntryFunction(scriptFunction);
    }
}
function toOptionalTransactionArgs(option) {
    if (option) {
        const extraArgs = {};
        if (option.maxGasAmount) {
            extraArgs.maxGasAmount = BigInt(option.maxGasAmount);
        }
        if (option.gasUnitPrice) {
            extraArgs.gasUnitPrice = BigInt(option.gasUnitPrice);
        }
        if (option.expireTimestamp) {
            extraArgs.expireTimestamp = BigInt(option.expireTimestamp);
        }
        return extraArgs;
    }
}
function toSubmitTransactionRequest(option) {
    if (option) {
        const options = {};
        if (option.maxGasAmount) {
            options.max_gas_amount = option.maxGasAmount.toString();
        }
        if (option.gasUnitPrice) {
            options.gas_unit_price = option.gasUnitPrice.toString();
        }
        if (option.expireTimestamp) {
            options.expiration_timestamp_secs = option.expireTimestamp.toString();
        }
        return options;
    }
}
function sendPayloadTx(client, account, payload, option) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield sendPayloadTxAndLog(client, account, payload, option, false);
    });
}
function sendPayloadTxAndLog(client, account, payload, option, log = true) {
    return __awaiter(this, void 0, void 0, function* () {
        // send BCS transaction
        if (payload instanceof aptos.TxnBuilderTypes.TransactionPayloadEntryFunction) {
            // RawTransaction
            const rawTxn = yield client.generateRawTransaction(account.address(), payload, toOptionalTransactionArgs(option));
            // Signed BCS representation
            const bcsTxn = aptos.AptosClient.generateBCSTransaction(account, rawTxn);
            const txnResult = yield client.submitSignedBCSTransaction(bcsTxn);
            yield client.waitForTransaction(txnResult.hash);
            const txDetails = (yield client.getTransactionByHash(txnResult.hash));
            if (log) {
                console.log(txDetails);
            }
            return txDetails;
        }
        // send JSON transaction
        else {
            const pld = payload;
            // RawTransaction
            const txn = yield client.generateTransaction(account.address(), pld, toSubmitTransactionRequest(option));
            // Signed json representation
            const signedTxn = yield client.signTransaction(account, txn);
            const txnResult = yield client.submitTransaction(signedTxn);
            yield client.waitForTransaction(txnResult.hash);
            const txDetails = (yield client.getTransactionByHash(txnResult.hash));
            if (log) {
                console.log(txDetails);
            }
            return txDetails;
        }
    });
}
const SIM_KEYS = {
    pubkey: new aptos.HexString('0xf9edd14bcf93b878ee1b97e68f336b96122665af351318a52ae20c7fbf89f8f2'),
    address: new aptos.HexString('0xf70ac33c984f8b7bead655ad239d246f1c0e3ca55fe0b8bfc119aa529c4630e8'),
};
function getSimulationKeys(account) {
    return {
        pubkey: account.pubKey(),
        address: account.address(),
    };
}
function simulatePayloadTx(client, keys, payload, option) {
    return __awaiter(this, void 0, void 0, function* () {
        return simulatePayloadTxAndLog(client, keys, payload, option, false);
    });
}
function simulatePayloadTxAndLog(client, keys, payload, option, log = true) {
    return __awaiter(this, void 0, void 0, function* () {
        if (payload instanceof aptos.TxnBuilderTypes.TransactionPayload) {
            const rawTxn = yield client.generateRawTransaction(keys.address, payload, toOptionalTransactionArgs(option));
            const bcsTxn = generateBCSSimulation(keys.pubkey, rawTxn);
            const outputs = yield client.submitBCSSimulation(bcsTxn);
            if (log) {
                console.log(outputs[0]);
            }
            return outputs[0];
        }
        else {
            const pld = payload;
            const txn = yield client.generateTransaction(keys.address, pld, toSubmitTransactionRequest(option));
            const transactionSignature = {
                type: "ed25519_signature",
                public_key: keys.pubkey.hex(),
                // use invalid signature for simulation
                signature: aptos.HexString.fromUint8Array(new Uint8Array(64)).hex(),
            };
            const request = {
                sender: keys.address.hex(),
                sequence_number: txn.sequence_number.toString(),
                max_gas_amount: txn.max_gas_amount.toString(),
                gas_unit_price: txn.gas_unit_price.toString(),
                expiration_timestamp_secs: txn.expiration_timestamp_secs.toString(),
                payload: pld,
                signature: transactionSignature,
            };
            const outputs = yield client.client.transactions.simulateTransaction(request);
            if (log) {
                console.log(outputs[0]);
            }
            return outputs[0];
        }
    });
}
function generateBCSSimulation(pubkey, rawTxn) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const txnBuilder = new aptos.TransactionBuilderEd25519((_signingMessage) => {
        // @ts-ignore
        const invalidSigBytes = new Uint8Array(64);
        return new aptos.TxnBuilderTypes.Ed25519Signature(invalidSigBytes);
    }, pubkey.toUint8Array());
    return txnBuilder.sign(rawTxn);
}
function takeSimulationValue(tx, tag, repo) {
    if (!tx.success) {
        console.log(tx);
        throw new Error("Simulation failed");
    }
    const valueData = tx.changes.filter((change) => {
        if (change.type !== "write_resource") {
            return false;
        }
        const wr = change;
        return wr.data.type === tag.getAptosMoveTypeTag();
    });
    if (valueData.length === 0) {
        throw new Error("Did not find output resource");
    }
    if (valueData.length > 1) {
        throw new Error("Found multiple output resource");
    }
    const wr = valueData[0];
    return repo.parse(wr.data.data, tag);
}

exports.ActualAggregator = ActualAggregator;
exports.ActualStringClass = ActualStringClass;
exports.ActualUsage = ActualUsage;
exports.AddressParser = AddressParser;
exports.AptosLocalCache = AptosLocalCache;
exports.AptosParserRepo = AptosParserRepo;
exports.AptosResourceCache = AptosResourceCache;
exports.AptosSyncedCache = AptosSyncedCache;
exports.AptosVectorU8 = AptosVectorU8;
exports.BoolParser = BoolParser;
exports.DummyCache = DummyCache;
exports.PackageMetadata = PackageMetadata;
exports.SIM_KEYS = SIM_KEYS;
exports.SimpleStructTag = SimpleStructTag;
exports.StructTag = StructTag$1;
exports.TypeParamIdx = TypeParamIdx;
exports.U128 = U128;
exports.U128Parser = U128Parser;
exports.U64 = U64;
exports.U64Parser = U64Parser;
exports.U8 = U8;
exports.U8Parser = U8Parser;
exports.UnsignedInt = UnsignedInt;
exports.UpgradePolicy = UpgradePolicy;
exports.VectorParser = VectorParser;
exports.VectorTag = VectorTag;
exports.abortCode = abortCode;
exports.aptos_framework_account_create_address = aptos_framework_account_create_address;
exports.aptos_framework_account_create_signer = aptos_framework_account_create_signer;
exports.aptos_framework_aggregator_add = aptos_framework_aggregator_add;
exports.aptos_framework_aggregator_destroy = aptos_framework_aggregator_destroy;
exports.aptos_framework_aggregator_factory_new_aggregator = aptos_framework_aggregator_factory_new_aggregator;
exports.aptos_framework_aggregator_read = aptos_framework_aggregator_read;
exports.aptos_framework_aggregator_sub = aptos_framework_aggregator_sub;
exports.aptos_framework_code_request_publish = aptos_framework_code_request_publish;
exports.aptos_framework_code_request_publish_with_allowed_deps = aptos_framework_code_request_publish_with_allowed_deps;
exports.aptos_framework_event_write_to_event_store = aptos_framework_event_write_to_event_store;
exports.aptos_framework_genesis_create_signer = aptos_framework_genesis_create_signer;
exports.aptos_framework_state_storage_get_state_storage_usage_only_at_epoch_beginning = aptos_framework_state_storage_get_state_storage_usage_only_at_epoch_beginning;
exports.aptos_framework_transaction_context_get_script_hash = aptos_framework_transaction_context_get_script_hash;
exports.aptos_framework_util_from_bytes = aptos_framework_util_from_bytes;
exports.aptos_std_any_from_bytes = aptos_std_any_from_bytes;
exports.aptos_std_aptos_hash_keccak256 = aptos_std_aptos_hash_keccak256;
exports.aptos_std_aptos_hash_ripemd160_internal = aptos_std_aptos_hash_ripemd160_internal;
exports.aptos_std_aptos_hash_sha2_512_internal = aptos_std_aptos_hash_sha2_512_internal;
exports.aptos_std_aptos_hash_sip_hash = aptos_std_aptos_hash_sip_hash;
exports.aptos_std_bls12381_aggregate_pubkeys_internal = aptos_std_bls12381_aggregate_pubkeys_internal;
exports.aptos_std_bls12381_aggregate_signatures_internal = aptos_std_bls12381_aggregate_signatures_internal;
exports.aptos_std_bls12381_signature_subgroup_check_internal = aptos_std_bls12381_signature_subgroup_check_internal;
exports.aptos_std_bls12381_validate_pubkey_internal = aptos_std_bls12381_validate_pubkey_internal;
exports.aptos_std_bls12381_verify_aggregate_signature_internal = aptos_std_bls12381_verify_aggregate_signature_internal;
exports.aptos_std_bls12381_verify_multisignature_internal = aptos_std_bls12381_verify_multisignature_internal;
exports.aptos_std_bls12381_verify_normal_signature_internal = aptos_std_bls12381_verify_normal_signature_internal;
exports.aptos_std_bls12381_verify_proof_of_possession_internal = aptos_std_bls12381_verify_proof_of_possession_internal;
exports.aptos_std_bls12381_verify_signature_share_internal = aptos_std_bls12381_verify_signature_share_internal;
exports.aptos_std_debug_print = aptos_std_debug_print;
exports.aptos_std_debug_print_stack_trace = aptos_std_debug_print_stack_trace;
exports.aptos_std_ed25519_public_key_validate_internal = aptos_std_ed25519_public_key_validate_internal;
exports.aptos_std_ed25519_signature_verify_strict_internal = aptos_std_ed25519_signature_verify_strict_internal;
exports.aptos_std_event_write_to_event_store = aptos_std_event_write_to_event_store;
exports.aptos_std_from_bcs_from_bytes = aptos_std_from_bcs_from_bytes;
exports.aptos_std_multi_ed25519_public_key_validate_internal = aptos_std_multi_ed25519_public_key_validate_internal;
exports.aptos_std_multi_ed25519_signature_verify_strict_internal = aptos_std_multi_ed25519_signature_verify_strict_internal;
exports.aptos_std_secp256k1_ecdsa_recover = aptos_std_secp256k1_ecdsa_recover;
exports.aptos_std_secp256k1_ecdsa_recover_internal = aptos_std_secp256k1_ecdsa_recover_internal;
exports.aptos_std_table_add_box = aptos_std_table_add_box;
exports.aptos_std_table_borrow_box = aptos_std_table_borrow_box;
exports.aptos_std_table_borrow_box_mut = aptos_std_table_borrow_box_mut;
exports.aptos_std_table_contains_box = aptos_std_table_contains_box;
exports.aptos_std_table_destroy_empty_box = aptos_std_table_destroy_empty_box;
exports.aptos_std_table_drop_unchecked_box = aptos_std_table_drop_unchecked_box;
exports.aptos_std_table_new_table_handle = aptos_std_table_new_table_handle;
exports.aptos_std_table_remove_box = aptos_std_table_remove_box;
exports.aptos_std_type_info_chain_id_internal = aptos_std_type_info_chain_id_internal;
exports.aptos_std_type_info_type_name = aptos_std_type_info_type_name;
exports.aptos_std_type_info_type_of = aptos_std_type_info_type_of;
exports.assert = assert;
exports.buildPayload = buildPayload;
exports.copy = copy;
exports.deep_eq = deep_eq;
exports.deserializeMoveValue = deserializeMoveValue;
exports.dyn_add = dyn_add;
exports.dyn_and = dyn_and;
exports.dyn_bitand = dyn_bitand;
exports.dyn_bitor = dyn_bitor;
exports.dyn_div = dyn_div;
exports.dyn_eq = dyn_eq;
exports.dyn_ge = dyn_ge;
exports.dyn_gt = dyn_gt;
exports.dyn_le = dyn_le;
exports.dyn_lt = dyn_lt;
exports.dyn_mod = dyn_mod;
exports.dyn_mul = dyn_mul;
exports.dyn_neq = dyn_neq;
exports.dyn_or = dyn_or;
exports.dyn_shl = dyn_shl;
exports.dyn_shr = dyn_shr;
exports.dyn_sub = dyn_sub;
exports.dyn_xor = dyn_xor;
exports.generateBCSSimulation = generateBCSSimulation;
exports.getShortAddressTypeTagFullname = getShortAddressTypeTagFullname;
exports.getShortAddressTypeTagParamlessName = getShortAddressTypeTagParamlessName;
exports.getSimulationKeys = getSimulationKeys;
exports.getTypeParamsString = getTypeParamsString;
exports.getTypeTagFullname = getTypeTagFullname;
exports.getTypeTagParamlessName = getTypeTagParamlessName;
exports.isAtomicTypeTag = isAtomicTypeTag;
exports.isTypeTagConcrete = isTypeTagConcrete;
exports.moveValueToOpenApiObject = moveValueToOpenApiObject;
exports.numbersOrStringToHexString = numbersOrStringToHexString;
exports.parseAtomicTag = parseAtomicTag;
exports.parseMoveStructTag = parseMoveStructTag;
exports.parseQualifiedStructTag = parseQualifiedStructTag;
exports.parseResourceType = parseResourceType;
exports.parseStructProto = parseStructProto;
exports.parseTypeParameter = parseTypeParameter;
exports.parseTypeTag = parseTypeTag;
exports.parseTypeTagOrThrow = parseTypeTagOrThrow;
exports.parseVectorTag = parseVectorTag;
exports.payloadArg = payloadArg;
exports.print = print;
exports.printerReplacer = printerReplacer;
exports.sendPayloadTx = sendPayloadTx;
exports.sendPayloadTxAndLog = sendPayloadTxAndLog;
exports.serializeMoveValue = serializeMoveValue;
exports.serializeMoveValueWithoutTag = serializeMoveValueWithoutTag;
exports.serializeStruct = serializeStruct;
exports.serializeVector = serializeVector;
exports.set = set;
exports.simulatePayloadTx = simulatePayloadTx;
exports.simulatePayloadTxAndLog = simulatePayloadTxAndLog;
exports.std_bcs_to_bytes = std_bcs_to_bytes;
exports.std_hash_sha2_256 = std_hash_sha2_256;
exports.std_hash_sha3_256 = std_hash_sha3_256;
exports.std_signer_borrow_address = std_signer_borrow_address;
exports.std_string_internal_check_utf8 = std_string_internal_check_utf8;
exports.std_string_internal_index_of = std_string_internal_index_of;
exports.std_string_internal_is_char_boundary = std_string_internal_is_char_boundary;
exports.std_string_internal_sub_string = std_string_internal_sub_string;
exports.std_unit_test_create_signers_for_testing = std_unit_test_create_signers_for_testing;
exports.std_vector_borrow = std_vector_borrow;
exports.std_vector_borrow_mut = std_vector_borrow_mut;
exports.std_vector_destroy_empty = std_vector_destroy_empty;
exports.std_vector_empty = std_vector_empty;
exports.std_vector_length = std_vector_length;
exports.std_vector_pop_back = std_vector_pop_back;
exports.std_vector_push_back = std_vector_push_back;
exports.std_vector_swap = std_vector_swap;
exports.strToU8 = strToU8;
exports.substituteTypeParams = substituteTypeParams;
exports.takeBigInt = takeBigInt;
exports.takeSimulationValue = takeSimulationValue;
exports.u128 = u128;
exports.u64 = u64;
exports.u8 = u8;
exports.u8ArrayArg = u8ArrayArg;
exports.u8str = u8str;
exports.veq = veq;
//# sourceMappingURL=index.js.map
